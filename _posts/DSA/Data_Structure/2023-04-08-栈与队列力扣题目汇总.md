---
categories: [DSA]
tags: DSA LeetCode C++
---

# å†™åœ¨å‰é¢



# æ ˆå…¥é—¨

ä¸»è¦ç”¨äºæ·±åº¦ä¼˜å…ˆæœç´¢, æ¨¡æ‹Ÿ**é€’å½’**è¿‡ç¨‹, ä»¥åŠä¸€äº›ç‰¹å®šè§£æ³•çš„é¢˜ç›®(ä¾‹å¦‚å•è°ƒæ ˆ, æ‹¬å·åŒ¹é…, é€†æ³¢å…°è¡¨è¾¾å¼æ±‚å€¼ç­‰), 

## åŸºæœ¬å®ç°

é€šè¿‡Cé£æ ¼æ•°ç»„å¾ˆå®¹æ˜“å®ç°æ ˆ(ä½†æ˜¯å›ºå®šäº†é•¿åº¦), åœ¨C++STLä¸­ä¹Ÿæœ‰å®ç°(é€šè¿‡deque), ä¸è¿‡åŸºæœ¬çš„æ ˆæ“ä½œè¿˜æ˜¯è¦ç”¨æ•°ç»„æ¥å®Œæˆ, è¦äº†è§£æ¯ä¸€ä¸ªAPIçš„å®ç°è¿‡ç¨‹. 



## åŸºæœ¬é¢˜ç›®

1.   [20. æœ‰æ•ˆçš„æ‹¬å· - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/valid-parentheses/);

     ```cpp
     // ğŸ’©ä¸€æ ·çš„ä»£ç 
     class Solution {
     public:
         bool isValid(string s) {
             if (s.size() & 1) return false;
             stack<char> st;
             for (auto c : s) {
                 if (c == '(' || c == '[' || c == '{')
                     st.push(c);
                 else if (st.empty())
                     return false;
                 else if (c == ')')
                     if (st.top() == '(')
                         st.pop();
                     else
                         return false;
                 else if (c == ']')
                     if (st.top() == '[')
                         st.pop();
                     else
                         return false;
                 else if (c == '}')
                     if (st.top() == '{')
                         st.pop();
                     else
                         return false;
             }
             return st.empty();
         }
     };
     // å®˜æ–¹çš„ä»£ç :
     class Solution {
     public:
         bool isValid(string s) {
             if (s.size() & 1) return false;
             stack<char> st;
             unordered_map<char, char> pairs{
                 {')', '('},
                 {']', '['},
                 {'}', '{'},
             };
             for (auto c : s) {
                 if (pairs.find(c) != pairs.end()) {
                     if (st.empty() || st.top() != pairs[c]) return false;
                     st.pop();
                 } else
                     st.push(c);
             }
             return st.empty();
         }
     };
     ```

2.    [921. ä½¿æ‹¬å·æœ‰æ•ˆçš„æœ€å°‘æ·»åŠ ](https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/);(å…¶ä¸­ä¹Ÿè•´å«äº†è´ªå¿ƒçš„æ€æƒ³, æ¯æ¬¡**å°±è¿‘**åŒ¹é…æ‹¬å·)
     ```cpp
     class Solution {
     public:
         int minAddToMakeValid(string s) {
             stack<char> st;
             for (char c : s) {
                 if (c == ')' && !st.empty() && st.top() == '(')
                     st.pop();
                 else
                     st.emplace(c);
             }
             return st.size();
         }
     };
     ```
     
     



# é˜Ÿåˆ—å…¥é—¨



ä¸»è¦ç”¨äºå¹¿åº¦ä¼˜å…ˆæœç´¢, ä»¥åŠä¸€äº›éœ€è¦åè¿›å…ˆå‡ºçš„æƒ…å†µ. 







# æ ˆè¿›é˜¶

## æœ€å°æ ˆ

[155. æœ€å°æ ˆ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/min-stack/);

STL: ç”¨ä¸¤ä¸ªæ ˆæ¥æ¨¡æ‹Ÿ. 

```cpp
class MinStack {
    stack<int> s1, m1;

public:
    MinStack() { m1.emplace(INT_MAX); }

    void push(int val) {
        s1.emplace(val);
        m1.emplace(min(getMin(), val));
    }

    void pop() { s1.pop(), m1.pop(); }

    int top() { return s1.top(); }

    int getMin() { return m1.top(); }
};
```

æ•°ç»„æ¨¡æ‹Ÿ:

```cpp
class MinStack {
    vector<int> s1, m1;

public:
    MinStack() { m1.emplace_back(INT_MAX); }

    void push(int val) {
        s1.emplace_back(val);
        m1.emplace_back(min(getMin(), val));
    }

    void pop() { s1.pop_back(), m1.pop_back(); }

    int top() { return s1.back(); }

    int getMin() { return m1.back(); }
};
```

$\bigstar$å•ä¸€æ ˆå®ç°: é€šè¿‡æ•°ç»„**å·®å€¼**æ¥åš: 

```cpp
class MinStack {
    stack<long> st; // é‡Œé¢å­˜çš„æ˜¯æ•°ä¹‹é—´çš„å·®å€¼
    long min_val;   // min_valæ¯æ¬¡åªå­˜æœ€å°å€¼
public:
    MinStack() : st(), min_val() {}

    void push(int val) {
        if (st.empty())
            st.emplace(0), min_val = val;
        else {
            long diff = val - min_val;
            st.emplace(diff);
            if (diff < 0) min_val = val; // æ›´æ–° min_val
        }
    }

    void pop() {
        long diff = st.top();
        st.pop();
        if (diff < 0) min_val -= diff; // æ›´æ–° min_val
    }

    int top() { return st.top() < 0 ? min_val : st.top() + min_val; }

    int getMin() { return min_val; }
};
```

æ•°ç»„æ¨¡æ‹Ÿ, å‡ ä¹åŒç™¾. 

```cpp
class MinStack {
    vector<long> st; // å­˜æ”¾å½“å‰å…¥æ ˆçš„å€¼å’Œå·²è®°å½•çš„æœ€å°å€¼çš„å·®
    long min_val;    // å·²è®°å½•çš„æœ€å°å€¼

public:
    MinStack() : st(), min_val() {}

    void push(int val) {
        if (st.empty())
            st.emplace_back(0), min_val = val; // é¦–å…ƒç´ (å·®å€¼)ä¸º0
        else {
            st.emplace_back(val - min_val);
            if (st.back() < 0) min_val = val; // å·®å€¼ä¸ºè´Ÿå€¼, æ›´æ–°æœ€å°å€¼
        }
    }

    void pop() {
        auto tmp{st.back()};
        if (tmp < 0) min_val -= tmp; // æœ€å°å€¼å¼¹å‡º, æ›´æ–°
        st.pop_back();
    }

    int top() { return st.back() > 0 ? min_val + st.back() : min_val; }

    int getMin() { return min_val; }
};
```



## æ ˆå†…æ’åº

[é¢è¯•é¢˜ 03.05. æ ˆæ’åº - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/sort-of-stacks-lcci/description/);

```cpp
class SortedStack {
    stack<int> st;

public:
    SortedStack() {}

    void push(int val) {
        function<void(int)> f = [&](int x) {
            if (st.empty() || st.top() >= x)
                st.emplace(x);
            else {
                auto t = st.top();
                st.pop();
                f(x);
                st.emplace(t);
            }
        };
        f(val);
    }

    void pop() {
        if (!isEmpty())
            st.pop();
    }

    int peek() {
        return isEmpty() ? -1 : st.top();
    }

    bool isEmpty() {
        return st.empty();
    }
};

```

æˆ–è€…åŒæ ˆ:

```cpp
class SortedStack {
    stack<int> st1, st2;

public:
    SortedStack() {}

    void push(int val) {
        if (st1.empty() || st1.top() >= val)
            st1.emplace(val);
        else {
            for (; !st1.empty() && st1.top() < val; st1.pop())
                st2.emplace(st1.top());
            st1.emplace(val);
            for (; !st2.empty(); st2.pop())
                st1.emplace(st2.top());
        }
    }

    void pop() {
        if (!isEmpty())
            st1.pop();
    }

    int peek() {
        return isEmpty() ? -1 : st1.top();
    }

    bool isEmpty() {
        return st1.empty();
    }
};
```



## å‹å…¥å¼¹å‡ºåºåˆ—

[946. éªŒè¯æ ˆåºåˆ— - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/validate-stack-sequences/description/);[å‰‘æŒ‡ Offer 31. æ ˆçš„å‹å…¥ã€å¼¹å‡ºåºåˆ— - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/description/);

ç›´æ¥æ¨¡æ‹Ÿå³å¯..

```cpp
class Solution {
public:
    bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {
        stack<int> st;
        int n = pushed.size();
        for (int i{}, j{}; i < n; ++i) {
            st.emplace(pushed[i]);
            while (!st.empty() && st.top() == popped[j])
                ++j, st.pop();
        }
        return st.empty();
    }
};
```





## ç”¨ä¸¤ä¸ªæ ˆå®ç°é˜Ÿåˆ—

[232. ç”¨æ ˆå®ç°é˜Ÿåˆ— - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/implement-queue-using-stacks/)

```cpp
class MyQueue {
    stack<int> in1, out1;

public:
    MyQueue() : in1(), out1() {}

    void push(int x) { in1.emplace(x); }

    int pop() {
        if (!out1.empty()) {
            int t{out1.top()};
            out1.pop();
            return t;
        }
        while (!in1.empty()) out1.emplace(in1.top()), in1.pop();
        int t1{out1.top()};
        out1.pop();
        return t1;
    }

    int peek() {
        int t{pop()};
        out1.emplace(t);
        return t;
    }

    bool empty() { return in1.empty() && out1.empty(); }
};
```

æ•°ç»„ä¼šå¿«å¾ˆå¤š:

```cpp
class MyQueue {
    vector<int> in1, out1;

public:
    MyQueue() : in1({}), out1({}) {}

    void push(int x) { in1.emplace_back(x); }

    int pop() {
        if (!out1.empty()) {
            int t{out1.back()};
            out1.pop_back();
            return t;
        }
        while (!in1.empty()) out1.emplace_back(in1.back()), in1.pop_back();
        int t1{out1.back()};
        out1.pop_back();
        return t1;
    }

    int peek() {
        int t{pop()};
        out1.emplace_back(t);
        return t;
    }

    bool empty() { return in1.empty() && out1.empty(); }
};
```



## é€†æ³¢å…°è¡¨è¾¾å¼æ±‚å€¼

æ ˆçš„ç»å…¸è¿ç”¨äº†

```cpp
class Solution {
public:
    long atoi(string s) {
        long ans{};
        bool isNeg = s[0] == '-';
        for (int i = isNeg; i < s.size(); ++i) ans = 10 * ans + s[i] - '0';
        return isNeg ? -ans : ans;
    }
    int evalRPN(vector<string>& tokens) {
        int lhs{}, rhs{};
        stack<int> st;
        for (string s : tokens) {
            if (isdigit(s[0]) || s.size() > 1 && '-' == s[0])
                st.push(atoi(s));
            else if (s[0] == '+') {
                rhs = st.top(), st.pop();
                lhs = st.top(), st.pop();
                st.push(lhs + rhs);
            } else if (s[0] == '-') {
                rhs = st.top(), st.pop();
                lhs = st.top(), st.pop();
                st.push(lhs - rhs);
            } else if (s[0] == '*') {
                rhs = st.top(), st.pop();
                lhs = st.top(), st.pop();
                st.push(lhs * rhs);
            } else if (s[0] == '/') {
                rhs = st.top(), st.pop();
                lhs = st.top(), st.pop();
                st.push(lhs / rhs);
            }
        }
        return st.top();
    }
};
```

å½“ç„¶, å¯ä»¥ç®€åŒ–ä¸€ä¸‹: (å†—ä½™ä»£ç å¤ªå¤šäº†)

```cpp
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<int> st;
        int n = tokens.size(), lhs, rhs;
        for (auto token : tokens) {
            if (isdigit(token[0]) || token.size() > 1 && token[0] == '-') {
                st.push(stoi(token));
            } else {
                rhs = st.top(), st.pop();
                lhs = st.top(), st.pop();
                switch (token[0]) {
                    case '+':
                        st.push(lhs + rhs);
                        break;
                    case '-':
                        st.push(lhs - rhs);
                        break;
                    case '*':
                        st.push(lhs * rhs);
                        break;
                    case '/':
                        st.push(lhs / rhs);
                        break;
                }
            }
        }
        return st.top();
    }
};
```

### æ•°ç»„æ¨¡æ‹Ÿæ ˆ

éœ€è¦è€ƒè™‘æ•°ç»„å¼€å¤šå¤§: 

è€ƒè™‘åˆ°ä¸€ä¸ªåˆæ³•çš„é€†æ³¢å…°è¡¨è¾¾å¼æ•°ç»„, å…¶é•¿åº¦ä¸€å®šæ˜¯ä¸€ä¸ªå¥‡æ•°(è‡³å°‘æ˜¯3, æ¯æ¬¡åŠ ä¸€ä¸ªæ“ä½œæ•°åŠ ä¸€ä¸ªæ“ä½œç¬¦)

å¹¶ä¸”, æ“ä½œæ•°è¦æ¯”æ“ä½œç¬¦çš„æ•°é‡å¤šä¸€ä¸ª, é‚£ä¹ˆå°±æ˜¯
$$
\begin{cases}
æ“ä½œæ•°ä¸ªæ•°:&\frac{n+1}2\\
æ“ä½œç¬¦ä¸ªæ•°:&\frac{n-1}2
\end{cases}
$$
è¿™æ ·ä¸€æ¥, æ•°ç»„é•¿åº¦é€‰å–ä¸º$\frac{n+1}2$å³å¯æ»¡è¶³æ¡ä»¶. 

```cpp
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        int n = tokens.size(), idx = -1;
        int st[(n + 1) / 2];
        for (auto token : tokens) {
            if (isdigit(token[0]) || token.size() > 1 && token[0] == '-') {
                st[++idx] = stoi(token);
            } else {
                switch (token[0]) {
                    case '+':
                        --idx;
                        st[idx] += st[idx + 1];
                        break;
                    case '-':
                        --idx;
                        st[idx] -= st[idx + 1];
                        break;
                    case '*':
                        --idx;
                        st[idx] *= st[idx + 1];
                        break;
                    case '/':
                        --idx;
                        st[idx] /= st[idx + 1];
                        break;
                }
            }
        }
        return st[idx];
    }
};
```




### é€’å½’è§£æ³•

é€’å½’é­”æ³•, ç›¸å½“äºåç€éå†

```cpp
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        int idx = tokens.size() - 1;
        function<int()> f = [&]() {
            if (tokens[idx].size() == 1 && !isdigit(tokens[idx][0])) {
                char op = tokens[idx--][0];
                int rhs = f(), lhs = f(), ans{};
                switch (op) {
                    case '+':
                        ans = lhs + rhs;
                        break;
                    case '-':
                        ans = lhs - rhs;
                        break;
                    case '*':
                        ans = lhs * rhs;
                        break;
                    default:
                        ans = lhs / rhs;
                }
                return ans;
            }
            return stoi(tokens[idx--]);
        };
        return f();
    }
};
```



## åŒ¹é…æ›¿æ¢åçš„å•è¯

 [1003. æ£€æŸ¥æ›¿æ¢åçš„è¯æ˜¯å¦æœ‰æ•ˆ](https://leetcode.cn/problems/check-if-word-is-valid-after-substitutions/);







# é˜Ÿåˆ—è¿›é˜¶



## ç”¨ä¸¤ä¸ªé˜Ÿåˆ—å®ç°æ ˆ

[225. ç”¨é˜Ÿåˆ—å®ç°æ ˆ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/implement-stack-using-queues/);

```cpp
// STL ä¸è®²æ­¦å¾·ç‰ˆ
class MyStack {
    deque<int> deq;

public:
    MyStack() {}

    void push(int x) { deq.emplace_back(x); }

    int pop() {
        int t = top();
        deq.pop_back();
        return t;
    }

    int top() { return deq.back(); }

    bool empty() { return deq.empty(); }
};
```

å½“ç„¶è‚¯å®šå¾—æ¥ä¸ªæ­£ç»çš„:

```cpp
class MyStack {
    queue<int> q1, q2;

public:
    MyStack() : q1(), q2() {}

    void push(int x) {
        if (q1.empty())
            q1.emplace(x);
        else {
            q2.emplace(x);
            for (; !empty(); q1.pop()) q2.emplace(q1.front());
            swap(q1, q2);
        }
    }

    int pop() {
        auto ans(top());
        q1.pop();
        return ans;
    }

    int top() { return q1.front(); }

    bool empty() { return q1.empty(); }
};
```

ä»¥åŠå•é˜Ÿåˆ—å®ç°: 

```cpp
class MyStack {
    queue<int> q;

public:
    MyStack() : q() {}

    void push(int x) {
        q.emplace(x);
        if (!q.empty())
            for (int n = q.size() - 1; n > 0; --n, q.pop())
                q.emplace(q.front());
    }

    int pop() {
        auto ans(top());
        q.pop();
        return ans;
    }

    int top() { return q.front(); }

    bool empty() { return q.empty(); }
};
```



## å¾ªç¯é˜Ÿåˆ—

[622. è®¾è®¡å¾ªç¯é˜Ÿåˆ—](https://leetcode.cn/problems/design-circular-queue/);

éœ€è¦çŸ¥é“ä¸‹é¢çš„å‡ ä¸ªå…¬å¼:
$$
\begin{cases}
size=(read-front+capcaity) \bmod capacity\\
empty: \ front == rear \\
full: \ front == (rear + 1) \bmod capacity \\
\end{cases}
$$

>   ä¸Šé¢çš„å˜é‡åå’Œä¸‹é¢ä»£ç ä¸­çš„ size å«ä¹‰ä¸åŒ, è¯·æ³¨æ„. 

```cpp
class MyCircularQueue {
    int front, rear, size;
    vector<int> arr;

public:
    MyCircularQueue(int k) : front(0), rear(0), size(k + 1), arr(size) {}

    bool enQueue(int value) {
        if (isFull()) return false;
        arr[rear] = value;
        rear = (rear + 1) % size;
        return true;
    }

    bool deQueue() {
        if (isEmpty()) return false;
        front = (front + 1) % size;
        return true;
    }

    int Front() { return isEmpty() ? -1 : arr[front]; }

    int Rear() { return isEmpty() ? -1 : arr[(rear - 1 + size) % size]; }

    bool isEmpty() { return rear == front; }

    bool isFull() { return ((rear + 1) % size) == front; }
};
```



## å¾ªç¯åŒç«¯é˜Ÿåˆ—



[641. è®¾è®¡å¾ªç¯åŒç«¯é˜Ÿåˆ—](https://leetcode.cn/problems/design-circular-deque/);

```cpp
class MyCircularDeque {
    int front, rear, size; // front æŒ‡å‘å¤´, rear æŒ‡å‘å°¾ç»“ç‚¹çš„ä¸‹ä¸€ä¸ª
    vector<int> arr;

public:
    MyCircularDeque(int k) : front(0), rear(0), size(k + 1), arr(size) {}

    bool insertFront(int value) {
        if (isFull()) return false;
        front = (front - 1 + size) % size;
        arr[front] = value;
        return true;
    }

    bool insertLast(int value) {
        if (isFull()) return false;
        arr[rear] = value;
        rear = (rear + 1) % size;
        return true;
    }

    bool deleteFront() {
        if (isEmpty()) return false;
        front = (front + 1) % size;
        return true;
    }

    bool deleteLast() {
        if (isEmpty()) return false;
        rear = (rear - 1 + size) % size;
        return true;
    }

    int getFront() { return isEmpty() ? -1 : arr[front]; }

    int getRear() { return isEmpty() ? -1 : arr[(rear - 1 + size) % size]; }

    bool isEmpty() { return rear == front; }

    bool isFull() { return ((rear + 1) % size) == front; }
};
```





# å•è°ƒæ ˆ

## å…¥é—¨çº§

1.   [496. ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´  I - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/next-greater-element-i/);(åŸºæœ¬çš„å•è°ƒæ ˆé¢˜ç›®)

     ```cpp
     class Solution {
     public:
         vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
             unordered_map<int, int> mp;
             stack<int> st;
             for (auto num : nums2) {
                 while (!st.empty() && num > st.top()) mp[st.top()] = num, st.pop();
                 st.emplace(num);
             }
             for (auto& num : nums1) num = mp.count(num) ? mp[num] : -1;
             return nums1;
         }
     };
     // åç€éå†
     class Solution {
     public:
         vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
             unordered_map<int, int> mp;
             stack<int> st;
             for (int i = nums2.size() - 1; i >= 0; --i) {
                 while (!st.empty() && nums2[i] > st.top()) st.pop();
                 mp[nums2[i]] = st.empty() ? -1 : st.top();
                 st.emplace(nums2[i]);
             }
             for (auto& num : nums1) num = mp[num];
             return nums1;
         }
     };
     ```

2.   [503. ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´  II - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/next-greater-element-ii/);(å¾ªç¯æ•°ç»„, å…³é”®æ˜¯å­˜ç´¢å¼•å’Œå–æ¨¡)

     ```cpp
     ```

3.   [907. å­æ•°ç»„çš„æœ€å°å€¼ä¹‹å’Œ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/sum-of-subarray-minimums/);
4.   [2104. å­æ•°ç»„èŒƒå›´å’Œ  - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/sum-of-subarray-ranges/);(å¯æš´åŠ›)
5.    [739. æ¯æ—¥æ¸©åº¦](https://leetcode.cn/problems/daily-temperatures/);
6.    [1673. æ‰¾å‡ºæœ€å…·ç«äº‰åŠ›çš„å­åºåˆ—](https://leetcode.cn/problems/find-the-most-competitive-subsequence/);
7.    



## è¿›é˜¶çº§

1.   [962. æœ€å¤§å®½åº¦å¡ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/maximum-width-ramp/);(å•è°ƒæ ˆæ±‚æœ€é•¿)

2.   [1124. è¡¨ç°è‰¯å¥½çš„æœ€é•¿æ—¶é—´æ®µ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/longest-well-performing-interval/);(ä¸Šä¸€ä¸ªé¢˜çš„å˜å¼, ä½¿ç”¨å“ˆå¸Œæ›´å¿«, è€Œå•è°ƒæ ˆæ›´æ™®é€‚)

     ```cpp
     ```

3.    [654. æœ€å¤§äºŒå‰æ ‘](https://leetcode.cn/problems/maximum-binary-tree/);(å¥½é¢˜, æ„é€ æ–¹æ³•å€¼å¾—å­¦ä¹ )
      ```cpp
      ```

4.    [84. æŸ±çŠ¶å›¾ä¸­æœ€å¤§çš„çŸ©å½¢](https://leetcode.cn/problems/largest-rectangle-in-histogram/);

      ```cpp
      ```

      



# å•è°ƒé˜Ÿåˆ—

## æ¨¡æ¿

 [é¢è¯•é¢˜59 - II. é˜Ÿåˆ—çš„æœ€å¤§å€¼](https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/);[å‰‘æŒ‡ Offer 59 - II. é˜Ÿåˆ—çš„æœ€å¤§å€¼](https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/);

```cpp
class MaxQueue {
    queue<int> q; // å­˜æ•°æ®
    deque<int> d; // å­˜æœ€å¤§å€¼
public:
    MaxQueue() : q(), d() {}

    int max_value() {
        if (d.empty()) return -1;
        return d.front();
    }

    void push_back(int value) {
        // ç§»é™¤æ— ç”¨å…ƒç´ 
        while (!d.empty() && d.back() < value) d.pop_back();
        d.push_back(value);
        q.emplace(value);
    }

    int pop_front() {
        if (q.empty()) return -1;
        auto ans{q.front()};
        // å¦‚æœå¾…åˆ é™¤å…ƒç´ æ˜¯æœ€å¤§å€¼, dé˜Ÿå¤´ä¹Ÿè¦åˆ é™¤
        if (ans == d.front()) d.pop_front();
        q.pop();
        return ans;
    }
};
```



## æ»‘åŠ¨çª—å£æœ€å¤§å€¼

 [239. æ»‘åŠ¨çª—å£æœ€å¤§å€¼](https://leetcode.cn/problems/sliding-window-maximum/);[å‰‘æŒ‡ Offer 59 - I. æ»‘åŠ¨çª—å£çš„æœ€å¤§å€¼](https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/);

### æ–¹æ³• 1: ä¼˜å…ˆé˜Ÿåˆ—

```cpp
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        int n = nums.size();
        priority_queue<pair<int, int>> pq;
        vector<int> ans(n - k + 1);
        for (int i{}; i < k; ++i) pq.emplace(nums[i], i);
        ans[0] = pq.top().first;
        for (int i{k}; i < n; ++i) {
            pq.emplace(nums[i], i);
            while (!pq.empty() && pq.top().second <= i - k) pq.pop();
            ans[i - k + 1] = pq.top().first;
        }
        return ans;
    }
};
```

### æ–¹æ³• 2: å•è°ƒé˜Ÿåˆ—(ç»å…¸æ–¹æ³•)

```cpp
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> ans(n - k + 1);
        deque<int> q;
        for (int i{}; i < n; ++i) {
            if (!q.empty() && q.front() == i - k) q.pop_front();
            while (!q.empty() && nums[i] > nums[q.back()]) q.pop_back();
            q.push_back(i);
            if (i >= k - 1) ans[i - k + 1] = nums[q.front()];
        }
        return ans;
    }
};
```



 [862. å’Œè‡³å°‘ä¸º K çš„æœ€çŸ­å­æ•°ç»„](https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/);

```cpp
```



 [1438. ç»å¯¹å·®ä¸è¶…è¿‡é™åˆ¶çš„æœ€é•¿è¿ç»­å­æ•°ç»„](https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/);

```cpp
```



# ä¼˜å…ˆé˜Ÿåˆ—



1.   [1792. æœ€å¤§å¹³å‡é€šè¿‡ç‡ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/maximum-average-pass-ratio/);(éœ€è¦äº†è§£åˆ°å¢é‡çš„é€’å‡æ€§, ä¸é”™çš„ä¼˜å…ˆé˜Ÿåˆ—é¢˜ç›®)

     ```cpp
     class Solution {
     public:
         double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {
             using pdii = pair<double, int>; // intå­˜ä¸‹æ ‡
             priority_queue<pdii> pq;
             int n = classes.size();
             for (int i{}; i < n; ++i) {
                 int a{classes[i][0]}, b{classes[i][1]};
                 double x = (a + 1.) / (b + 1) - a * 1. / b;
                 pq.push({x, i});
             }
             while (extraStudents--) {
                 auto [_, i] = pq.top();
                 pq.pop();
                 int &a{classes[i][0]}, &b{classes[i][1]};
                 ++a, ++b;
                 pq.push({(a + 1.) / (b + 1) - a * 1. / b, i});
             }
             double ans{};
             while (!pq.empty()) {
                 auto [_, i] = pq.top();
                 pq.pop();
                 ans += classes[i][0] * 1. / classes[i][1];
             }
             return ans / n;
         }
     };
     ```

     

2.   [å‰‘æŒ‡ Offer 41. æ•°æ®æµä¸­çš„ä¸­ä½æ•°](https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/);[295. æ•°æ®æµçš„ä¸­ä½æ•°](https://leetcode.cn/problems/find-median-from-data-stream/);(é€šè¿‡æœ‰åºé›†åˆä¹Ÿå¯ä»¥åš, ä½†æ˜¯éœ€è¦è€ƒè™‘çš„ç‚¹æ¯”è¾ƒå¤š)

     ```cpp
     class MedianFinder {
         priority_queue<int, vector<int>> queMin; // å¤§æ ¹å †
         //(å †é¡¶å…ƒç´ æ˜¯å°äºç­‰äºä¸­ä½æ•°çš„æœ€å¤§å€¼)
         priority_queue<int, vector<int>, greater<int>> queMax; // å¤§äºä¸­ä½æ•°çš„æœ€å°å€¼
     public:
         MedianFinder() {}
     
         void addNum(int num) {
             if (queMin.empty() || num <= queMin.top()) {
                 queMin.emplace(num);
                 // è°ƒæ•´(æ»¡è¶³ä¸­ä½æ•°æ€§è´¨)
                 if (queMax.size() + 1 < queMin.size())
                     queMax.emplace(queMin.top()), queMin.pop();
             } else {
                 queMax.emplace(num);
                 if (queMin.size() < queMax.size())
                     queMin.emplace(queMax.top()), queMax.pop();
             }
         }
     
         double findMedian() {
             if (queMin.size() > queMax.size()) return queMin.top();
             return (queMin.top() + queMax.top()) / 2.0;
         }
     };
     ```

     æ‰‹å†™å †å®ç°: (æ¨¡ç‰ˆæ‰æ˜¯å¥½ä¸œè¥¿, å‡å°‘ä»£ç , ç›¸å½“äºç”Ÿæˆä»£ç çš„ä»£ç äº†, æ‰€ä»¥æ‰å«å…ƒç¼–ç¨‹)

     ```cpp
     template <typename T, class Compare = less<T>>
     class Priority_Queue { // é»˜è®¤å°æ ¹å †
         vector<T> arr;
         size_t len;
         Compare comp;
     
     public:
         Priority_Queue() : arr(), len() {}
     
         int top() { return arr[0]; }
         bool empty() { return len == 0; }
         int size() { return len; }
     
         void pop() {
             if (len == 0) return;
             arr[0] = arr[--len]; // å¼¹å‡ºé˜Ÿå¤´å…ƒç´ 
             arr.pop_back();
             int i{};
             for (;;) { // Heapify
                 int tmp{i}, l{2 * i + 1}, r{2 * i + 2};
                 if (l < len && comp(arr[l], arr[tmp])) tmp = l;
                 if (r < len && comp(arr[r], arr[tmp])) tmp = r;
                 if (tmp != i) {
                     swap(arr[i], arr[tmp]);
                     i = tmp;
                 } else
                     break;
             }
         }
         void push(int key) {
             arr.emplace_back(key);
             for (auto i{len++}; i > 0 && comp(arr[i], arr[(i - 1) / 2]);
                  i = (i - 1) / 2)
                 swap(arr[(i - 1) / 2], arr[i]);
         }
     };
     
     class MedianFinder {                     // è®¾ä¸­ä½æ•°ä¸º x
         Priority_Queue<int, greater<>> left; // å·¦åŠéƒ¨åˆ†[min,x)
         Priority_Queue<int> right;           // å³è¾¹éƒ¨åˆ†[x,max]
     public:
         MedianFinder() {}
     
         void addNum(int num) {
             if (right.empty() || right.top() <= num) {
                 right.push(num);
                 if (right.size() > left.size() + 1)
                     left.push(right.top()), right.pop();
             } else {
                 left.push(num);
                 if (left.size() > right.size()) right.push(left.top()), left.pop();
             }
         }
     
         double findMedian() {
             if (left.size() < right.size())
                 return right.top();
             else
                 return (left.top() + right.top()) / 2.;
         }
     };
     ```

3.   [786. ç¬¬ K ä¸ªæœ€å°çš„ç´ æ•°åˆ†æ•° - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/k-th-smallest-prime-fraction/description/);

     ```cpp
     class Solution {
     public:
         vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {
             using ptype = pair<int, int>;
             auto cmp = [](const auto& lhs, const auto& rhs) {
                 return lhs.first * rhs.second > lhs.second * rhs.first;
             };
             priority_queue<ptype, vector<ptype>, decltype(cmp)> pq(cmp);
             int n = arr.size();
             for (int i{}; i < n - 1; ++i)
                 for (int j{i + 1}; j < n; ++j) pq.emplace(arr[i], arr[j]);
             for (int i{1}; i < k; ++i, pq.pop())
                 ;
             return {pq.top().first, pq.top().second};
         }
     };
     ```

     

4.   [23. åˆå¹¶ K ä¸ªå‡åºé“¾è¡¨ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/merge-k-sorted-lists/description/);

     ```cpp
     class Solution {
     public:
         ListNode* mergeKLists(vector<ListNode*>& lists) {
             if (lists.empty()) return {};
             auto cmp = [](const auto& lhs, const auto& rhs) {
                 return lhs->val > rhs->val;
             };
             priority_queue<ListNode*, vector<ListNode*>, decltype(cmp)> pq(cmp);
             int k = lists.size();
             auto dum = new ListNode, cur = dum;
             for (auto node : lists)
                 if (node) pq.emplace(node);
     
             for (; !pq.empty(); pq.pop(), cur = cur->next) {
                 auto tmp = pq.top();
                 if (tmp) cur->next = tmp;
                 if (tmp->next) pq.emplace(tmp->next);
             }
             return dum->next;
         }
     };
     ```

4.   [1851. åŒ…å«æ¯ä¸ªæŸ¥è¯¢çš„æœ€å°åŒºé—´ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/minimum-interval-to-include-each-query/description/);

     ```cpp
     ```
     
     
