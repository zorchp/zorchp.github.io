---
categories: [Python]
tags: Python Debug
---

# 问题

看下面这样一段代码, 想要去除邻接表中重复的边(无向图), 

```python
tb1 = [((0, 1), 2), ((1, 0), 2), ((1, 3), 3),
       ((1, 4), 2), ((2, 4), 1), ((3, 1), 3),
       ((3, 4), 4), ((4, 1), 2), ((4, 2), 1),
       ((4, 3), 4)]

for ((i, j), k) in tb1:
    # 对于无向图需要进行判断
    if i > j:
        tb1.remove(((i, j), k))
print(tb1)
```

得到了下面的结果:

```python
[((0, 1), 2), ((1, 3), 3), ((1, 4), 2), ((2, 4), 1), ((3, 4), 4), ((4, 2), 1)]

```

最后一个元素并未被删除, 并且遍历显示`((4, 2), 1)`这个元素并未被遍历. 

# 原因分析

这里受到@栋栋颻的启发, 在采用`for ... in ...`语句对列表等结构进行遍历时, 如果进行删除, 则被删除元素的下一个元素会自动补充到`in`指向的元素中, 这就导致`41`被删除之后`42`直接补充到了`41`的位置, 然后`in`继续进行下一轮的遍历, `42`就未被遍历了, 通过索引+`while`的方式可以避免这个问题的出现. 



```python
tb1 = [((0, 1), 2), ((1, 0), 2), ((1, 3), 3),
       ((1, 4), 2), ((2, 4), 1), ((3, 1), 3),
       ((3, 4), 4), ((4, 1), 2), ((4, 2), 1),
       ((4, 3), 4)]
i = 0
N = len(tb1)
while len(tb1) > N // 2:
    if tb1[i][0][0] > tb1[i][0][1]:
        tb1.remove(tb1[i])
        i -= 1
    i += 1
print(tb1)
```

得到正确的结果:

```python
[((0, 1), 2), ((1, 3), 3), ((1, 4), 2), ((2, 4), 1), ((3, 4), 4)]

```

